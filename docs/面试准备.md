# 简历

**项目名称**：基于前后端分离的博客网站开发

**技术选型**：Spring + Mybatis-plus + MySQL + Redis

**项目描述**：本项目建立了一个博客网站，完成了从需求分析、数据库设计、到后端功能代码实现的整体开发流程。功能主要包含登录注册模块、最热文章查询、更新文章被阅读次数、系统日志追踪、文章管理等功能。从中学习到了Spring、Mybatis-plus、MySQL等技术栈。

**亮点：**

-   ~~利用JWT + redis实现了登录功能，并利用AOP + ThreadLocal保存登录用户信息~~
-   ~~利用AOP实现了系统日志，统一缓存处理，~~~~统一异常处理的功能~~
-   ~~利用线程池 + CAS实现更新文章被阅读次数功能~~



# 总结

## 功能

### 最热文章查询

**Service层的实现类中利用mybatis-plus实现查询**

- 条件构造器Wrapper（sql语句的筛选条件）

 条件构造器其实就是一个对象，以方法的形式提供了数据库操作的筛选关键字

 我们调用该对象，来拼接我们的筛选条件即可。

- selectPage就是分页查询

- Active Record：对应表中的一行记录，所以返回结果是records

- 不能直接返回从数据库取出的数据，需要利用Vo处理下

    >   Spring提供的BeanUtils.copyProperties()：用于快速复制java bean，只对相同的属性进行复制



**mybatisplus 无法进行多表查询,需要使用mybatis的xml文件实现接口**

-   利用tag_name as tagName使数据库中的列名和类中的属性名一致
-   xml中的#{}中的参数是接口中的参数



**一般是从controller开始写，写到service，再写到dao(mapper)**

先写出sql语句

```sql
SELECT tag_id
		FROM ms_article_tag
		GROUP BY tag_id
		ORDER BY COUNT(*) DESC 
		LIMIT 3
```

>   CollectionUtils.isEmpty的作用：用来对集合null和空的判断，因为sql中的in关键字不能为空
>
>   如果为空，赋值为空值，返回Collections.emptyList()



collection是针对参数，如果参数是list，则使用此标签，利用foreach遍历

```xml
    <!-- List<Tag> findTagsByTagIds(List<Long> tagIds);-->
    <select id="findTagsByTagIds" parameterType="list" resultType="com.mszlu.blog.dao.pojo.Tag">
        select id,tag_name as tagName from ms_tag
        where id in
        <foreach collection="tagIds" item="tagId" separator="," open="(" close=")">
            #{tagId}
        </foreach>
    </select>
```



**最热文章总结：**

1.   Controller定义ArticleController类中的hotArticle的方法

     >   -   Controller层需要标注
     >
     >       在类上：@PostMapping，@RestController
     >
     >   -   返回值为Result

2.   Service需要先定义接口ArticleService中的hotArticle的方法

     >   -   Service需要标注
     >
     >       在类上：@Service
     >
     >       成员变量中：@Autowaired
     >
     >   -   返回值为Result

3.   Service层的实现类中重写hotArticle方法

     >   -   返回值为Result
     >
     >   -   利用mybatis-plus，定义LambdaQueryWrapper，实现单表查询
     >
     >   -   由于前端要的数据和我们直接从数据库中拿到的数据不完全一样
     >
     >       需要用copyList(articles,false,false)将数据封装成Vo对象返回



**文章列表分页查询总结：**

1.   在config目录下的MybatisPlusConfig类中配置分页拦截器

     >   -   需要标注
     >
     >       在类上：
     >
     >       @Configuration
     >
     >       @MapperScan("com.mszlu.blog.dao.mapper")
     >
     >       在方法上：
     >
     >       @Bean
     >
     >   -   新建MybatisPlusInterceptor对象，为该对象添加分页拦截器
     >
     >       ```java
     >       @Bean
     >           public MybatisPlusInterceptor mybatisPlusInterceptor(){
     >               MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
     >               interceptor.addInnerInterceptor(new PaginationInnerInterceptor());
     >               return interceptor;
     >           }
     >       ```

1.   在Service的实现类ArticleServiceImpl中，重写listArticle方法

     >   定义Page对象
     >
     >   ```java
     >   Page<Article> page = new Page<>(pageParams.getPage(), pageParams.getPageSize());
     >   ```
     >
     >   利用mp定义LambdaQueryWrapper查询对象
     >
     >   ```java
     >   queryWrapper.orderByDesc(Article::getWeight,Article::getCreateDate);
     >   ```
     >
     >   利用dao层对象调用selectPage方法得到分页结果
     >
     >   ```java
     >   Page<Article> articlePage = articleMapper.selectPage(page, queryWrapper);
     >   List<Article> records = articlePage.getRecords();
     >   ```

2.   封装成前端需要的数据进行返回



**封装前端请求对象返回：**

1.   先新建一个Vo的前端需要的类的数据结构

2.   在相应ServiceImpl中，实现copy和copyList方法

     >   copyList:
     >
     >   定义一个List<vo>，循环调用copy方法，将结果加入List中
     >
     >   copy:
     >
     >   定义vo对象
     >
     >   利用BeanUtils.copyProperties将数据中相同字段的属性快速复制
     >
     >   将其他不一样的属性分别处理



**返回一篇文章所有的tag总结：**

因为mp无法实现多表查询，所以需要mybatis的Xml文件实现

1.   定义TagService接口中findTagsByArticleId方法

     >   返回值不是Result，说明可能是被其他service调用的service,也就是不是前端请求显示的独立功能，所以controller中也没有相应的函数

2.   在TagServiceImpl类中重写findTagsByArticleId方法

     >   利用dao层对象，调用findTagsByArticleId方法
     >
     >   封装数据

3.   首先在TagMapper.java中定义方法findTagsByArticleId

     ```java
     public interface TagMapper extends BaseMapper<Tag> {
     
         List<Tag> findTagsByArticleId(Long articleId);
     }
     ```

4. 在resources中的相应目录文件下创建TagMapper.xml,并进行mapper映射

    blog\blog-api\blog-api\src\main\resources\com\mszlu\blog\dao\mapper\TagMapper.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <!--MyBatis配置文件-->
    <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    
    <mapper namespace="com.mszlu.blog.dao.mapper.TagMapper">
    
        <!-- List<Tag> findTagsByArticleId(Long articleId);-->
        <select id="findTagsByArticleId" parameterType="long" resultType="com.mszlu.blog.dao.pojo.Tag">
            <!-- 数据库中的列名为：tag_name as tagName，这样就和类中的属性名一致 -->
            select id,avatar,tag_name as tagName from  ms_tag
            where id in
            (select tag_id from ms_article_tag where article_id=#{articleId})
        </select>
        <!-- List<Long> findHotsTagIds(int limit);-->
        <select id="findHotsTagIds"  parameterType="int" resultType="java.lang.Long">
            SELECT  tag_id FROM `ms_article_tag` group by tag_id order by count(*) desc limit #{limit}
        </select>
        <!-- List<Tag> findTagsByTagIds(List<Long> tagIds);-->
        <select id="findTagsByTagIds" parameterType="list" resultType="com.mszlu.blog.dao.pojo.Tag">
            select id,tag_name as tagName from ms_tag
            where id in
            <foreach collection="tagIds" item="tagId" separator="," open="(" close=")">
                #{tagId}
            </foreach>
        </select>
    </mapper>
    ```

    利用tag_name as tagName使数据库中的列名和类中的属性名一致

    

### controller层统一异常处理功能

不管是controller层还是service，dao层，都有可能报异常，如果是预料中的异常，可以直接捕获处理，如果是意料之外的异常，需要统一进行处理，进行记录，并给用户提示相对比较友好的信息。

**关键注解：**

**@ControllerAdvice**【修饰在类上】

**@ExceptionHandler(Exception.class)**【修饰在方法上】

> 概念：
>
> 是spring提供的新注解,本质上还是@Component ，是@Controller增强器, 可以对controller中使用到@RequestMapping注解的一下方法做逻辑处理。
>
> 做异常处理：
>
> 通常和 @ExceptionHandler注解结合使用,当异常抛到controller层时,可以对异常进行统一的处理,规定返回的json格式或者跳转到指定的错误页面等.

```java
//对加了@Controller注解的方法进行拦截处理 AOP的实现
@ControllerAdvice
public class AllExceptionHandler {
    //进行异常处理，处理Exception.class的异常
    @ExceptionHandler(Exception.class)
    @ResponseBody //返回json数据,不加的话是页面
    public Result doException(Exception ex){
        ex.printStackTrace();
        return Result.fail(-999,"系统异常");
    }

}
```

![image-20220607232915121](appendix/面试准备/image-20220607232915121.png)

**AOP统一异常处理总结**

1.   定义AllExceptionHandler类

     >   -   需要标注
     >
     >       在类上：@ControllerAdvice
     >
     >       在方法上：@ExceptionHandler(Exception.class），@ResponseBody 

2.   在类中编写doException方法printStackTrace异常



### 登录模块

#### JWT

##### 概念

首先明确jwt是一种token。Json web token (JWT), 该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。



##### 和传统session的区别

**传统session**

http协议本身是一种无状态的协议，用户的每一次请求都必须提供信息进行用户认证。为了减少这种信息的冗余，我们在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。



**缺点**

-   **Session**: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。

-   **扩展性**: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。



**使用token的原因**

基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。



##### JWT的组成

header：{“type”:“JWT”,“alg”:“HS256”} 固定【可被解密】

payload：存放信息，比如，用户id，过期时间等等，可以被解密，不能存放敏感信息【可被解密】

signature：签证，**A和B加上秘钥** 加密而成，只要秘钥不丢失，可以认为是安全的。【不可被解密，安全的】

jwt 验证，主要就是验证signature是否合法。



##### 去中心化的token验证流程

-   客户端提交账号和密码到服务端。

-   通过登录验证后，服务端响应由 JWT 生成的 Token 令牌。

-   客户端要访问服务器中其他资源，会在请求中带着 Token 到服务端。

-   服务端接收到请求之后，从 Token 中拿出 header 和 payload ，然后通过HS256算法将 header 和 payload 和 “盐” 值 进行计算得出内容，让计算出的内容与Token中的第三部分，也就是Signature去比较，如果一致则验证通过，反之则失败。

    >   注意此过程中，服务器是可以不进行token或者其他的信息的存储，使用token本身的三部分进行验证！



##### 中心化的token验证流程

-   客户端提交账号和密码到服务端。
-   通过登录验证后，服务端响应由 JWT 生成的 Token 令牌
-   服务器保存token在redis中
-   客户端要访问服务器中其他资源，会在请求中带着 Token 到服务端。
-   服务端接收到请求之后，先验证token是否合法。从 Token 中拿出 header 和 payload ，然后通过HS256算法将 header 和 payload 和 “盐” 值 进行计算得出内容，让计算出的内容与Token中的第三部分，也就是Signature去比较，如果一致则验证通过，反之则失败。
-   验证通过后再去redis中进行认证



**登录**

>   -   客户端提交账号和密码到服务端。
>   -   通过登录验证后，服务端响应由 JWT 生成的 Token 令牌
>   -   服务器保存token和user id的映射在redis中

**获取资源（获取用户信息）：**

>   -   客户端要访问服务器中其他资源，会在请求中带着 Token 到服务端。
>   -   服务端接收到请求之后，对token进行合法性验证
>       -   是否为空
>       -   解析是否一致
>       -   redis是否存在
>
>   -   验证失败则返回，否则返回相应的LoginUserVo

**使用中心化的token的验证的原因**

-   防止出现伪造token的情况，增加了安全性
-   登录用户做了token和user id的映射缓存，减少了查表的操作
-   可以扩展功能，使服务器对token做一些操作，比如灵活控制用户的过期（续期，踢掉线）



#### 代码

##### 登录

接口url：/login

请求方式：POST

请求参数：

| 参数名称 | 参数类型 | 说明 |
| -------- | -------- | ---- |
| account  | string   | 账号 |
| password | string   | 密码 |

返回数据：【后端给前端返还数据】

```json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": "token"
}
```



**注意:**

使用了事务

检查string类型是否为空

```java
(StringUtils.isBlank(account) 
```

使用DigestUtils.md5Hex(password + salt);进行加密



queryWrapper的相关方法：

```java
queryWrapper.eq(SysUser::getAccount,account); //等值判断
queryWrapper.select(SysUser::getAccount,SysUser::getId,SysUser::getAvatar,SysUser::getNickname); //查询，同时对应方法的返回结果
queryWrapper.last("limit 1"); //追加
```

都是dao层去调用selectOne，selectList，selectPage方法，毕竟dao层通过maybatis-plus去访问数据库

sysUserMapper.selectOne(queryWrapper);



**登录总结**

1.   在utils包中定义JWTUtils类，写入createToken和checkToken的方法

     >   createToken:
     >
     >   利用JWT原理，利用盐和HS256加密userid，并设置过期时间，返回token
     >
     >   checkToken:
     >
     >   利用JWT原理，判断signature部分是否合法，合法则返回Map<token,user>

2.   LoginController

     >   -   需要标注：
     >
     >       在类上：@RestController，@RequestMapping("login")
     >
     >       在成员变量上：@Autowired
     >
     >       在方法上：@PostMapping
     >
     >       在参数上：@RequestBody

3.   由于request参数是两个，我们可以定义一个LoginParam类的数据结构

4.   ServiceImpl中，重写login方法

     >   检查参数是否合法
     >   合法然后对密码进行加密，因为数据库中的密码是加密的,DigestUtils.md5Hex(password + salt);
     >   检查用户名密码是否正确，也就是去数据库中查找是否用户名和密码
     >
     >   ```java
     >   queryWrapper.eq(SysUser::getPassword,password);进行对比
     >   queryWrapper.last("limit 1");
     >   return sysUserMapper.selectOne(queryWrapper);
     >   ```
     >
     >   如果不存在，则返回失败。利用StringUtils.isBlank(account) 方法
     >   如果存在则生成token，返回给前端
     >   将token和用户的映射关系存入redis
     >
     >   ```java
     >   redisTemplate.opsForValue().set("TOKEN_"+token, JSON.toJSONString(sysUser),100, TimeUnit.DAYS);
     >   ```

     

##### 用户请求资源时验证token

登录以后要显示在页面上，所以使用了Result作为返回值



得从http的header里面拿到这个参数，这样传参相对来说安全一些，
返回的数据是我们用户相关的数据，id，账号、昵称和头像

接口url：/users/currentUser

请求方式：GET

请求参数：

| 参数名称      | 参数类型 | 说明            |
| ------------- | -------- | --------------- |
| Authorization | string   | 头部信息(TOKEN) |

返回数据：

```json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": {
        "id":1,
        "account":"1",
        "nickaname":"1",
        "avatar":"ss"
    }
}
```

功能：

验证token合法性，根据token查用户，最后返回用户



**用户请求资源验证token总结**

1.   UsersController

     >   -   需要标注：
     >
     >       在类上：@RestController，@RequestMapping("users")
     >
     >       在成员变量上：@Autowired
     >
     >       在方法上：@GetMapping("currentUser")
     >
     >       在参数上：@RequestHeader("Authorization")
     >
     >   -   写currentUser方法，调用sysUserService.findUserByToken(token);
     >
     >       返回值为Result

2.   SysUserServiceImpl重写findUserByToken方法进行验证

     >   调用loginService.checkToken
     >
     >   ```java
     >   判断token是否为空
     >   不为空则调用JWTUtils.checkToken解析token的合法性
     >   如果解析成功则去redis缓存中获取用户
     >   如果没有则表示缓存失效，或者不存在当前用户（缓存失效是不是意味着要重新登录，还是说这里只是Redis的二次验证）
     >   返回用户JSON.parseObject(userJson, SysUser.class);
     >   ```
     >
     >   如果得到的用户不为空，则将用户封装成Vo对象返回给前端
     >
     >   否则则表示用户验证不通过



**退出登录总结**

1.   LoginServiceImpl

     退出登录相当于是清除redis中缓存

     ```java
     @Override
         public Result logout(String token) {
             redisTemplate.delete("TOKEN_"+token);
             return Result.success(null);
         }
     ```

     

##### 注册

主要是注册的时候使用事务



接口url：/register

请求方式：POST

请求参数：

| 参数名称 | 参数类型 | 说明 |
| -------- | -------- | ---- |
| account  | string   | 账号 |
| password | string   | 密码 |
| nickname | string   | 昵称 |

返回数据：

```json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": "token"
}
```

>   感觉sysuser中的account和avater有点重复了



**注册总结**

1.   RegisterController

     >   需要标注：
     >
     >   在类上：@RestController，@RequestMapping("register")
     >
     >   在成员变量上：@Autowired
     >
     >   在方法上：@PostMapping
     >
     >   在参数上：@RequestBody

2.   定义类LoginParam封装前端请求的数据结构

3.   LoginServiceImpl中重写register方法

     >   判断参数 是否合法
     >
     >   调用sysUserService.findUserByAccount判断账户是否存在，
     >
     >   存在 返回账户已经被注册
     >
     >   不存在，则新建 SysUser对象，设置相关属性，调用sysUserService.save保存到数据库中（其实调用的mp写好的insert方法）
     >
     >   
     >
     >   //感觉没有必要加token，在登录时就做了
     >
     >   生成token
     >
     >   存入redis 并返回
     >
     >   
     >
     >   注意 加上事务，一旦中间的任何过程出现问题，注册的用户 需要回滚

     

##### 登录拦截器

**SpringMVC**

每次访问需要登录的资源的时候，都需要在代码中进行判断，一旦登录的逻辑有所改变，代码都得进行变动，非常不合适。

那么可不可以统一进行登录判断呢？

> springMVC中拦截器
>
> 可以，使用拦截器，进行登录拦截，如果遇到需要登录才能访问的接口，如果未登录，拦截器直接返回，并跳转登录页面。



**登录拦截器总结**

**1.编写拦截器**

实现HandlerInterceptor接口

重写preHandle方法

```java

/**
         * 1. 需要判断 请求的接口路径 是否为 HandlerMethod (controller方法)
         （因为还存在静态资源，不是方法，可能是一些网页啥的，需要将这些过滤掉）
         * 2. 判断 token是否为空，如果为空 未登录，进行拦截
         * 3. 如果token 不为空，验证token， loginService.checkToken
         * 4. 如果认证成功 放行
         */
```

>   注意：
>
>   -   因为如果失败了，需要给网页返回信息
>
>       就要设置格式
>
>       前后端分离，格式为json
>
>       ```java
>       response.setContentType("application/json;charset=utf-8");
>       response.getWriter().print(JSON.toJSONString(result));
>       ```

2.**设置需要拦截的窗口（页面）**

实现WebMvcConfigurer接口

重写addInterceptors方法

```java
@Configuration
public class WebMVCConfig implements WebMvcConfigurer {

    @Autowired
    private LoginInterceptor loginInterceptor;

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        //跨域配置
        registry.addMapping("/**").allowedOrigins("http://localhost:8080");
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
    //假设拦截test接口后续实际遇到拦截的接口时，再配置真正的拦截接口
        registry.addInterceptor(loginInterceptor)
                .addPathPatterns("/test");
    }
}

```

3.**写一个需要被拦截的窗口**

```java
@RestController
@RequestMapping("test")
public class TestController {

    @RequestMapping
    public Result test(){
        return Result.success(null);
    }
}
```



##### 保存用户信息

由于每次请求资源都需要token验证，很麻烦，我们验证完，就可以将得到用户的信息进行保存，同时也不需要频繁的传递token

可以利用threadLocal保存用户信息，以便controller层直接获取



**利用UserThreadLocal保存用户信息总结**

1.   写一个UserThreadLocal的类

     >   定义成员变量，需要定义为private static final类型
     >
     >   定义put,set,remove的static 方法

2.    在LoginInterceptor类中preHandle的重写方法中，将验证过的用户信息，put进来

     在LoginInterceptor类中afterCompletion的重写方法中，需要将threadlocal删除

3.   在需要使用用户信息的controller中进行get

     >   可以参考文章的publish方法



### 文章详情

@Configuration可理解为用spring的时候xml里面的<beans>标签，标注类

@Bean可理解为用spring的时候xml里面的<bean>标签，标注方法



**文章详情总结**

1.   ArticleServiceImpl重写findArticleById方法

     >   1.   调用articleMapper.selectById查询id对应的文章
     >
     >   2.   调用copy封装article数据为vo,此处用到了方法的重载
     >
     >        ```java
     >        1. 创建vo对象
     >        2. 利用BeanUtils.copyProperties复制相同的属性
     >        3. 设置其他atricle中不一样的参数(分开后都是单表查询)
     >           	- 设置id，因为article中的id是long型，articleVo中的是string类型
     >        	- 设置时间，因为article中的是bigint型，articleVo中的是string类型
     >            - 设置tag,调用tagService.findTagsByArticleId(articleId)方法，返回List<TagVo>
     >            - 设置author,调用sysUserService.findUserById(authorId).getNickname()
     >            - 设置body，调用findArticleBodyById(bodyId)，返回ArticleBodyVo
     >            - 设置category，调用categoryService.findCategoryById(categoryId)，返回CategoryVo
     >            - 本来应该在这里更新阅读数的，但是考虑性能问题，更新阅读数要写表，写表要加锁，同时阻塞了其他读的操作，只有当更新完文章才能加载出来，所以利用线程池技术，不仅解决了效率问题哪怕更新出问题，也不会影响查看操作。
     >        ```
     >
     >   3.   利用线程池更新阅读数，调用threadService.updateArticleViewCount
     >
     >        ```markdown
     >        1. 写一个ThreadPoolConfig配置类
     >            - 需要在类上添加注解 @Configuration，@EnableAsync
     >            - 创建asyncServiceExecutor方法，返回值为Executor
     >            - 在方法上注解： @Bean("taskExecutor")
     >        2. 创建一个ThreadService类
     >        	- 在类上添加注解：@Component
     >        	- 创建updateArticleViewCount方法，并在方法上注解@Async("taskExcutor")（对应）
     >        	- 更新思路一：
     >        		获取当前的viewCounts数，注意是Integer类型
     >        		创建一个Article对象，设置viewCount+1，用于后面更新
     >        		创建LambdaQueryWrapper，获取当前文章的id和数据库中的id相等的对象
     >        		利用CAS，先对比此时的viewCount和刚才拿到的是否一致，一致才更新
     >            - 优化后更新思路二：（算了吧感觉没太看懂，应该是什么缓存一致性的问题）
     >            	将view_count直接存入redis中，使用redis中的increment函数，本身就是CAS的
     >            	（redisTemplate.opsForHash().increment("view_count",String.valueOf(article.getId()),1);）
     >        ```
     >
     >        附录：设置线程池
     >
     >        ```java
     >         @Bean("taskExecutor")
     >            public Executor asyncServiceExecutor() {
     >                ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
     >                // 设置核心线程数
     >                executor.setCorePoolSize(5);
     >                // 设置最大线程数
     >                executor.setMaxPoolSize(20);
     >                //配置队列大小
     >                executor.setQueueCapacity(Integer.MAX_VALUE);
     >                // 设置线程活跃时间（秒）
     >                executor.setKeepAliveSeconds(60);
     >                // 设置默认线程名称
     >                executor.setThreadNamePrefix("码神之路博客项目");
     >                // 等待所有任务结束后再关闭线程池，因为是异步任务，需要进行控制
     >                executor.setWaitForTasksToCompleteOnShutdown(true);
     >                //执行初始化
     >                executor.initialize();
     >                return executor;
     >            }
     >        ```
     >
     >        利用CAS更新：
     >
     >        ```java
     >        Integer viewCounts = article.getViewCounts();
     >                Article articleupdate = new Article();
     >                articleupdate.setViewCounts(viewCounts+1);
     >                LambdaQueryWrapper<Article> updatewrapper = new LambdaQueryWrapper<>();
     >                //根据id更新
     >                updatewrapper.eq(Article::getId ,article.getId());
     >                //设置一个为了在多线程的环境下线程安全
     >                //改之前再确认这个值有没有被其他线程抢先修改，类似于CAS操作 cas加自旋，加个循环就是cas
     >                updatewrapper.eq(Article ::getViewCounts,viewCounts );
     >                // update article set view_count=100 where view_count=99 and id =111
     >                //实体类加更新条件
     >                articleMapper.update(articleupdate,updatewrapper);
     >        ```
     >
     >        整个findArticleById方法：
     >
     >        ```java
     >        public ArticleVo findArticleById(Long id) {
     >                Article article = articleMapper.selectById(id);
     >                //线程池
     >                threadService.updateViewCount(articleMapper,article);
     >                return copy(article,true,true,true,true);
     >            }
     >        ```



### AOP方式实现日志



**日志总结**

1.   在需要使用日志的类上加注解@LogAnnotation，比如listArticle，也就是定义连接点joinPoint

     ```java
     @PostMapping
         //加上此注解，代表要对此接口记录日志
         @LogAnnotation(module = "文章",operation = "获取文章列表")
         public Result listArticle(@RequestBody PageParams pageParams){
     
             return articleService.listArticle(pageParams);
     
         }
     ```

2.   创建LogAnnotation注解，也就是定义切点

     ```java
     @Target(ElementType.METHOD) //该注解可以放在方法上
     @Retention(RetentionPolicy.RUNTIME) //该注解运行时生效
     @Documented
     public @interface LogAnnotation {
         //模块名称：类
         String module() default "";
         //操作名称：方法
         String operation() default "";
     }
     ```

3.   创建LogAspect类，定义切面（类），切面中定义通知（方法）和切点

     -   在类上注解@Aspect,表示时一个切面；@Slf4j使用lombok的日志

     -   写pt()方法，在此方法上注解@Pointcut("@annotation(com.mszlu.blog.common.aop.LogAnnotation)")，表示是哪个切点

     -   写log方法，也就是写通知，注解@Around("pt()")，是环绕通知

         >   point.proceed();是执行原有的业务逻辑的方法，在此之前是前置通知，在此之后是后置通知
         >
         >   通知的返回结果是业务代码执行后的结果

     -   调用recordLog方法，实现日志记录

         >   需要先调用连接点的参数链表，以确定是多态中的哪个方法，然后获取方法
         >
         >   创建logAnnotation对象，以便获取module和operation
         >
         >   log记录相应的module和operation，请求的方法名，请求的参数，以及相应的ip（找的工具包），执行时间
         >
         >   ![image-20220616005508362](appendix/面试准备/image-20220616005508362.png)

     -   附录

         ```java
         @Component
         @Aspect //切面 定义了通知和切点的关系
         @Slf4j
         public class LogAspect {
         
            //切点 ：我们刚才自定义的注解@Pointcut("@annotation(com.mszlu.blog.common.aop.LogAnnotation)")
             public void pt(){
             }
         
             //环绕通知：前后都可以进行增强
             @Around("pt()")
             public Object log(ProceedingJoinPoint point) throws Throwable {
                 long beginTime = System.currentTimeMillis();
                 //执行方法，调用原有的方法
                 Object result = point.proceed();
                 //执行时长(毫秒)
                 long time = System.currentTimeMillis() - beginTime;
                 //保存日志
                 recordLog(point, time);
                 return result;
         
             }
         
             private void recordLog(ProceedingJoinPoint joinPoint, long time) {
                 MethodSignature signature = (MethodSignature) joinPoint.getSignature();
                 Method method = signature.getMethod();
                 LogAnnotation logAnnotation = method.getAnnotation(LogAnnotation.class);
                 log.info("=====================log start================================");
                 log.info("module:{}",logAnnotation.module());
                 log.info("operation:{}",logAnnotation.operation());
         
                 //请求的方法名
                 String className = joinPoint.getTarget().getClass().getName();
                 String methodName = signature.getName();
                 log.info("request method:{}",className + "." + methodName + "()");
         
         //        //请求的参数
                 Object[] args = joinPoint.getArgs();
                 //转为字符串
                 String params = JSON.toJSONString(args[0]);
                 log.info("params:{}",params);
         
                 //获取request 设置IP地址
                 HttpServletRequest request = HttpContextUtils.getHttpServletRequest();
                 log.info("ip:{}", IpUtils.getIpAddr(request));
         
         
                 log.info("excute time : {} ms",time);
                 log.info("=====================log end================================");
             }
         ```



### AOP实现缓存

使用场景：

因为有大量用户短时间内进入到了详情页，所以可以把活动列表缓存起来，直接读缓存就可以了。防止过量访问



**实现缓存总结**

1.   在需要使用日志的类上加注解  @Cache(expire = 5 * 60 * 1000,name = "hot_article")，比如hotArticle，也就是定义连接点joinPoint

     ```java
        @PostMapping("hot")
     //5分钟，单位是毫秒
         @Cache(expire = 5 * 60 * 1000,name = "hot_article")
         public Result hotArticle(){
             int limit = 5;
             return articleService.hotArticle(limit);
         }
     ```

2.   创建Cache注解，也就是定义切点

     ```java
     @Target({ElementType.METHOD})
     @Retention(RetentionPolicy.RUNTIME)
     @Documented
     public @interface Cache {
     	//过期时间
         long expire() default 1 * 60 * 1000;
     	//缓存前缀标识
         String name() default "";
     
     }
     ```

3.   创建CacheAspect类，定义切面（类），切面中定义通知（方法）和切点

     -   在类上注解@Aspect,表示时一个切面；@Slf4j使用lombok的日志

     -   写pt()方法，在此方法上注解

         ```java
         @Pointcut("@annotation(com.mszlu.blog.common.cache.Cache)")
             public void pt(){}
         ```

     -   注入redis对象

     -   写around方法，也就是写通知，注解@Around("pt()")，是环绕通知

         >   point.proceed();是执行原有的业务逻辑的方法，在此之前是前置通知，在此之后是后置通知

     -   around方法具体逻辑

         >   1.   获取redis的键
         >
         >        需要先调用连接点的参数链表，以确定是多态中的哪个方法，然后获取方法
         >
         >        获得className,methodName,参数列表args，参数类型的列表parameterTypes，并对参数列表进行序列化params
         >
         >        将params进行MD5算法
         >
         >        利用method.getAnnotation获取cache注解的参数
         >
         >        设置redis的键为：缓存名+类名+方法名+参数
         >
         >   2.   查看redis中是否有对应的键，如果有则直接取出缓存,并利用JSON.parseObject返回成result的对象
         >
         >        ```java
         >        redisTemplate.opsForValue().get(redisKey);
         >        return JSON.parseObject(redisValue, Result.class);
         >        ```
         >
         >   3.   如果没有则进行缓存，执行原来的方法，将结果保存下来（也就是需要缓存的结果），放入redis，并按注解中的参数设置过期时间，然后将结果进行返回
         >
         >        ```java
         >        Object proceed = pjp.proceed();
         >                   redisTemplate.opsForValue().set(redisKey,JSON.toJSONString(proceed), Duration.ofMillis(expire));
         >        return proceed;
         >        ```

     -   附录

         缓存的代码

         ```java
         @Around("pt()")
             public Object around(ProceedingJoinPoint pjp){
                 try {
                     //pjp就是要使用通知的方法
                     Signature signature = pjp.getSignature();
                     //类名
                     //AticleController
                     String className = pjp.getTarget().getClass().getSimpleName();
                     //调用的方法名
                     //hotArticle()
                     String methodName = signature.getName();
         
         
                     Class[] parameterTypes = new Class[pjp.getArgs().length];
                     Object[] args = pjp.getArgs();
                     //参数
                     String params = "";
                     for(int i=0; i<args.length; i++) {
                         if(args[i] != null) {
                             params += JSON.toJSONString(args[i]);
                             parameterTypes[i] = args[i].getClass();
                         }else {
                             parameterTypes[i] = null;
                         }
                     }
                     if (StringUtils.isNotEmpty(params)) {
                         //加密 以防出现key过长以及字符转义获取不到的情况
                         params = DigestUtils.md5Hex(params);
                     }
                     Method method = pjp.getSignature().getDeclaringType().getMethod(methodName, parameterTypes);
                     //获取Cache注解
                     Cache annotation = method.getAnnotation(Cache.class);
                     //缓存过期时间
                     long expire = annotation.expire();
                     //缓存名称
                     String name = annotation.name();
                     //先从redis获取
                     String redisKey = name + "::" + className+"::"+methodName+"::"+params;
                     String redisValue = redisTemplate.opsForValue().get(redisKey);
                     if (StringUtils.isNotEmpty(redisValue)){
                         log.info("走了缓存~~~,{},{}",className,methodName);
                         return JSON.parseObject(redisValue, Result.class);
                     }
                     //如果为空，则走原来的业务代码
                     Object proceed = pjp.proceed();
                     redisTemplate.opsForValue().set(redisKey,JSON.toJSONString(proceed), Duration.ofMillis(expire));
                     log.info("存入缓存~~~ {},{}",className,methodName);
                     return proceed;
                 } catch (Throwable throwable) {
                     throwable.printStackTrace();
                 }
                 return Result.fail(-999,"系统错误");
             }
         ```





## 数据库表设计

主键：`bigint(0)`

>   **为什么不设置为long**
>
>   主键设置为id，刚开始设置为了long，造成了越界，所以要改为bigint
>
>   **为什么是bigint(0)，0代表什么**
>
>   整型数系统已经限制了取值范围，tinyint占1个字节、int占4个字节。所以整型数后面的m不是表示的数据长度，而是表示数据在显示时显示的最小长度

时间：`bigint(0)`

>   **数据库中可以用datetime、bigint、timestamp来表示时间，那么选择什么类型来存储时间比较合适呢？**
>
>   ![image-20220418192842409](appendix/面试准备/image-20220418192842409-16559548598391.png)
>
>   ```sql
>   long time = System.currentTimeMillis();
>   
>   bigint：timeLong(time)
>   
>   datetime ：new Date(time) 【YYYY-MM-DD  HH:mm:ss 】
>   
>   timestamp：new Timestamp(time)【 1970.1.1到现在的毫秒数】
>   ```
>
>   查询性能：bigint > datetime > timestamp
>
>   时间排序性能：bigint > timestamp > datetime
>
>   总结：
>
>   如果需要对时间字段进行操作(如通过时间范围查找或者排序等)，推荐使用bigint；
>
>   如果时间字段不需要进行任何操作，推荐使用timestamp，因为：
>
>   - DateTime没有时区，Timestamp与时区相关，在不同时区，查询到同一条记录此字段的值会不一样，随机应变
>   - DateTime 类型耗费空间更大(8字节)，Timestamp(4字节)，

用户名：`varchar(255)`

密码：`varchar(64)`【MD5 + 加密盐】

>   **什么是加密盐？**
>
>   在密码学中，是指在散列之前将散列内容（例如：密码）的任意固定位置插入特定的字符串。
>
>   **为什么加加密盐？**
>
>   -   密码不能明文存储
>   -   在对用户密码进行加密时，需要考虑对密码进行掩饰，即使是相同的密码，也应该要保存为不同的密文，以防密码泄漏
>   -   即使用户输入的是弱密码，也需要考虑进行增强，从而增加密码被攻破的难度
>
>   **怎么实现？**
>
>   ```java
>   String pwd = DigestUtils.md5Hex(password + slat);
>   ```

评论数量：` int(0)`

文章内容： `longtext`

>   最大长度4294967295个字节 (2^32-1)

手机号：`varchar(64)`

>   **为什么不用bigint**
>
>   1.   首先，手机号的本质是字符串而不是数字，只是恰巧长得像数字而已。
>
>   2.   字符串可以通过LINK去匹配，查询很方便。 
>
>   3.   手机号可能有-（座机），用int存不了。

row_format（dynamic）：每条记录所占用的字节不一定一样（比如varchar），其优点节省空间，缺点增加读取的时间开销。

>   row_format（fixed）：每条记录所占用的字节一样（比如int），其优点读取快，缺点浪费额外一部分空间。  





## 遇到的问题

### 问题一

问题：在阅读更新次数的时候，导致是否置顶的值被错更为0

原因：articleUpdate.setviewsCounts(viewCounts+1)，但是weight字段是int类型，类初始化时，赋值其为0，mybatisplus规则是但凡不是null就会生成到sql语句中进行更新，所以更新了错误的值

![image-20220614013057064](appendix/面试准备/image-20220614013057064.png)

解决：

将int改为Integer

```java
@Data
public class Article {

    public static final int Article_TOP = 1;

    public static final int Article_Common = 0;

    private Long id;

    private String title;

    private String summary;

    private Integer commentCounts;

    private Integer viewCounts;
    ...
}
```



### 问题二

问题：评论失败，显示获取不到文章

原因：分布式id 比较长，传到前端 会有精度损失，必须转为string类型 进行传输

解决：

-   使用序列化

```java
public class CommentVo  {
    //防止前端 精度损失 把id转为string
    @JsonSerialize(using = ToStringSerializer.class)
    private Long id;
```

-   直接声明为String



## 面试问题

[参考链接一](https://blog.csdn.net/weixin_48610702/article/details/115859656?utm_source=app&app_version=5.0.1&code=app_1562916241&uLinkId=usr1mkqgl919blen)

[参考链接二](https://blog.csdn.net/lijiaming_99/article/details/120922916)

### 项目的基础功能有哪些？

用户登录，注册，评论、发布、编辑文章

首页展示文章列表、最新标签、最热文章、文章归档；搜索文章（模糊搜索）、文章分类

系统日志追踪、文章管理等功能



### 什么是Spring框架



### 对Spring IoC的理解



### 什么是DAO



### Spring中关于Bean的注解



### Spring MVC是什么，是怎样的工作流程

服务器分为表现层/业务层/数据层，其中Spring MVC是工作在表现层，作用是接收/解析用户发送的请求，调用对应的业务类，根据业务类返回的结果（ModelAndView)，调用view进行视图渲染，并将渲染后的View返回给请求者。具体分为以下8步。

    客户端（浏览器）发送请求给前端处理器（DispatcherServlet)(发送请求，响应结果)；
    DispatcherServlet根据请求信息调用HandlerMapping，查找到对应的Handler；
    查找到对应的Handler(也就是Controller)后，由HandlerAdapter适配器处理；
    HandlerAdapter根据Handler来调用真正的Controller；
    Controller进行业务处理，返回ModelAndView对象，Model是数据对象，View是逻辑上的View；
    ViewResolver根据逻辑view找到实际view；
    DispatcherServlet把Model传给view进行视图渲染，然后返回给请求者。

C - Controller：控制器。接受用户请求，调用 Model 处理，然后选择合适的View给客户。
M - Model：模型。业务处理模型，接受Controller的调遣，处理业务，处理数据。
V - View：视图。返回给客户看的结果。

### DispatcherServlet处理流程？

 DispatcherServlet 处理流程：

在整个 Spring MVC 框架中，DispatcherServlet 处于核心位置，它负责协调和组织不同组件完成请求处理并返回响应工作。DispatcherServlet 是 SpringMVC统一的入口，所有的请求都通过它。DispatcherServlet 是前端控制器，配置在web.xml文件中，Servlet依自已定义的具体规则拦截匹配的请求，分发到目标Controller来处理。 初始化 DispatcherServlet时，该框架在web应用程序WEB-INF目录中寻找一个名为[servlet-名称]-servlet.xml的文件，并在那里定义相关的Beans，重写在全局中定义的任何Beans。在看DispatcherServlet 类之前，我们先来看一下请求处理的大致流程：

    Tomcat 启动，对 DispatcherServlet 进行实例化，然后调用它的 init() 方法进行初始化，在这个初始化过程中完成了：对 web.xml 中初始化参数的加载；建立 WebApplicationContext(SpringMVC的IOC容器)；进行组件的初始化；
    客户端发出请求，由 Tomcat 接收到这个请求，如果匹配 DispatcherServlet 在 web.xml中配置的映射路径，Tomcat 就将请求转交给 DispatcherServlet 处理；
    DispatcherServlet 从容器中取出所有 HandlerMapping 实例（每个实例对应一个 HandlerMapping接口的实现类）并遍历，每个 HandlerMapping 会根据请求信息，通过自己实现类中的方式去找到处理该请求的 Handler(执行程序，如Controller中的方法)，并且将这个 Handler 与一堆 HandlerInterceptor (拦截器)封装成一个 HandlerExecutionChain 对象，一旦有一个 HandlerMapping 可以找到 Handler则退出循环；
    DispatcherServlet 取出 HandlerAdapter 组件，根据已经找到的 Handler，再从所有HandlerAdapter 中找到可以处理该 Handler 的 HandlerAdapter 对象；
    执行 HandlerExecutionChain 中所有拦截器的 preHandler() 方法，然后再利用
    HandlerAdapter 执行 Handler ，执行完成得到 ModelAndView，再依次调用拦截器的
    postHandler() 方法；
    利用 ViewResolver 将 ModelAndView 或是 Exception（可解析成 ModelAndView）解析成View，然后 View 会调用 render() 方法再根据 ModelAndView 中的数据渲染出页面；
    最后再依次调用拦截器的 afterCompletion() 方法，这一次请求就结束了。

### 拦截器的作用

目的：让未登录用户不能访问某些页面
原理：在方法前标注自定义注解，拦截所有的请求，只处理带有该注解的方法。

### 什么是SSM框架？

包括Spring + Spring MVC(和Spring天生集成) + MyBatis（帮你和数据库打交道的框架，简单的设置，你就可以像Java一样，操作数据库了）



### 什么是Interceptor，在项目的哪里使用到了Interceptor?

Interceptor是SpringMVC的处理器（handler)拦截器，用于对处理器进行预处理和后处理。

-   分页查询
-   登录拦截器
-   异常处理拦截器



-   缓存
-   日志





### 是怎样实现统一捕获异常的？

在SpringBoot的项目某一路径下，加上对应的错误页面，发生错误时自动会跳转。服务器的三层结构中，错误会层层向上传递，所以只需要在表现层（controller)统一处理错误即可。
方法：在controller中加上advice包，并通过注解@ControllerAdvice和@ExceptionHandler，统一捕获异常。



### 是怎样实现统一记录日志的？

使用了AOP技术（面向切面编程），这里使用到的是SpringAOP。 AOP技术能够将哪些与业务，但是为业务模块共同调用的逻辑或责任（比如事务处理，日志记录，权限控制等），封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的扩展性和维护性。 SpringAOP本质上基于动态代理，当要代理的对象实现了某接口，会使用JDK动态代理，在运行时通过创建接口的代理实例，织入代码。当要代理的对象没有实现接口，则使用Cglib技术（编译时增强），通过子类代理织入代码。



### 什么是Redis，Redis有哪些优点？

概念：redis是一个非关系型数据库，数据存储在内存中，读写速度快。可以存储键和五种不同类型值的映射。只能以字符串为键，值支持：字符串，列表，无序集合，有序集合，hash散列表。
优点：由于数据存储在内存中，读写速度非常快，满足高性能，高并发的系统要求。与Java原生的map/guava相比，支持分布式缓存。与memcached相比，支持更丰富的数据类型，且支持数据持久化。



### 怎么往Spring框架中配置Redis，介绍常见的Redis操作

如何配置：
1，导入jar包
2，配置端口，以及配置类redisTemplate（注入连接工厂/设置序列化方式（json））
常见操作
Value类型：redisTemplate.opsForValue().set(redisKey, 1)，redisTemplate.opsForValue().get(redisKey)， redisTemplate.opsForValue().increment(redisKey)，
Hash类型：redisTemplate.opsForHash().put(redisKey, “id”, 1)， 还有get等操作
List类型：redisTemplate.opsForList().leftPush(redisKey, 101)， 还有size, index, range， leftPop等操作
Set类型：add, size, pop, members等操作
Zset类型：redisTemplate.opsForZSet().add(redisKey, “Linda”, 92), 有socre，rank，reverseRank， range等操作
操作key：可以delete，以及设置过期时间
同时支持绑定操作，支持事务（编程式事务，在事务中一般不包含查询）
为什么不包含查询：redis事务就是一系列命令的批量操作，批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。

### 项目中Redis的作用

1、事务操作：redisTemplate直接调用opfor…来操作redis数据库，每执行一条命令是要重新拿一个连接，因此很耗资源，让一个连接直接执行多条语句的方法就是使用SessionCallback，同样作用的还有RedisCallback，但不常用。
2、使用redis存储验证码：

    因为验证码需要频繁的进行访问与刷新，因此对性能的要求较高；
    验证码不需要永久保存，通常在很短的时间后就会失效；
    分布式部署的时候，存在session共享的问题。

3、使用redis存储登录凭证：
因为后台在每次处理请求的时候都要查询用户的登录凭证，访问的频率非常高，因此需要使用redis存储。
4、使用redis缓存用户信息：
因为后台在每次处理请求的时候都要根据用户的凭证用户信息，访问的频率非常高。
5、Redis可以使用zset对需要排序的数据进行自定义的排序。

### 访问过多

利用缓存、消息队列



### 项目中具体的功能点如何优化

-   更新阅读次数，改为了线程池更新

-   利用threadlocal进行验证用户的保存



### 项目中遇到的最大的问题如何解决的



### 登录



### 如果优化从哪些点来优化

-   搜索，es

-   评论数据，可以考虑放入mongodb当中。电商系统当中 评论数据放入mongo中

    >   mongodb适合放松散结构的数据

-   为了加快访问速度，部署的时候，可以把图片，js，css等放入七牛云存储中，加快网站访问速度

-   阅读数和评论数 ，考虑把阅读数和评论数 增加的时候 放入redis incr自增，使用定时任务 定时把数据固话到数据库当中

    >   [mongodb](https://blog.csdn.net/yanpenglei/article/details/79261875)
    >   [redis incr](https://www.cnblogs.com/sheseido/p/11243341.html)

### 某某技术栈的作用



### 文章是否有热榜排序功能？使用的是Redis那个数据结构？
